
###
	Data Model

	
###
	All actions are synchronous and blocking


#### Node.js

#####
kisia.js
	environment = {
		gitworm: {
			base: base-directory
			},
		graphql: {
			port: port
			// port
			},
		sqlite: {
			},
		tool: {
			}
		}

#####
	// functions relating to apis and processing
	tool.subcommand.subcommand_().subcommand_()
	tool.subcommand.subcommand().subcommand_().action

#####
	// workspace is a set of files - these are active files, and
	// they are not part of the model - updates to the workspace
	// files are not traxcked by any audit trail
	kisia.workspace = Workspace(environment)
	workspace = kisia.workspace

	// this reads and writes data from the workspace documents.  These
	// are stored
	workspace.read(workspacePointerNameOrPath)
	workspace.json(workspacePointerNameOrPath)
	workspace.write(workspacePointerNameOrPath,serializer=json)

	// asserts data about a pointer
	// Question: should we scan this from the filesystem?
	workspace.assertPointer(name,path,...args)
	workspace.retractPointer(workspacePointerNameOrPath)

	// Pointer to model, Pointer from model
	psetbuiler = workspace.pointerSetBuilder()

	// save this to model as
	model.assert()
 
	// 
	workspace.mergePointers(jsonPointerModel)

#####
	// direct access to model (workspace is gitworm checkout)
	// environment : default jsonification/serialization model

	// gitworm model:
	//		{
	//			blob: {
	//				<key>:<value>		// raw byte files
	//				}
	//			docptrs: [
	//					{... name,path,key,mimeType },
	//				]
	//			graph: {
	//				}
	//			index: {
	//				<index-name>: {
	//					key: [graph-pointer]
	//					}
	//				}
	//		}
	kisia.gitworm = GitWorm(environment)
	model = kisia.gitworm
	await model.read('property.json.path')
	await model.begin()

	// begin a txn if not already, merge into old txn if present
	// and then commit if txn is prese
	await model.assert('property.json.path',value,note:Note,txn?={})
	gwait model.merge('property.json.path',value,note:Note,txn?={})
	await model.retract('property.json.path',note:Note,txn?={})

	await model.commit()

##### Active Memory
	// executes a graphql query and returns the result
	kisia.graphql = GraphQL(environmentSettings)
	graphql = kisia.graphql

	// this executes read or read/write against the graphql
	// server, using standard objects.  the   
	graphql.query(graphQLQuery)
	graphql.mutate(graphQLMutation)

	// this attaches a sqlite database at a specific location
	// in the query tree
	graphql.attachSqlite(database)

##### 
	// used to create a sqlite database driver that supports three
	// commands.  the environment settings are not known
	// the runtime to create databases
	kisia.sqlite = SqlLite(environmentSettings)
	sqlite = kisia.sqlite

	// works with sqlite databases - you have the complete node sqlite
	// api, and your choice of memory or file based databases.  File based
	// databases and memory databases are generated by executing commands
	// against a list of table generators which generate tables by summarizing
	// the results
	database = sqlite.openFile(workspaceDocPtr)
	database = sqlite.recordQueryToMemory(name,graphQLQuery,[tableGenerators])
	database = sqlite.recordQueryToFile(workspaceDocPtr,graphQLQuery,[tableGenerators])

	// enhanced sqlitebiter api
	sqlite.biter.*
		.importFromCSV()
		.exportToXLSX()
		.exportToGoogleSheets()

#### Python

kisia.py
	cmd.subcommand.subcommand()
	cmd.subcommand_.subcommand_()


